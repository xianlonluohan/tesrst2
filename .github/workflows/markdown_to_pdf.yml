name: Markdown to PDF Converter - Fixed Version

on:
  push:
    branches: ["main", "master"]
    tags: ["v*", "pdf-*"]
  pull_request:
    branches: ["main", "master"]
  workflow_dispatch:

permissions:
  contents: write
  pages: write
  id-token: write

jobs:
  convert-md-to-pdf:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Install all dependencies (Ubuntu 24.04 compatible)
        run: |
          sudo apt-get update
          
          # 基本系统工具
          sudo apt-get install -y \
            wget \
            curl \
            git \
            tree \
            jq \
            python3 \
            python3-pip \
            poppler-utils \
            imagemagick
          
          # Pandoc
          sudo apt-get install -y pandoc
          
          # 完整安装 TeX Live（包括所有中文支持）
          echo "安装 TeX Live 完整版（可能需要几分钟）..."
          
          # 首先安装基础包
          sudo apt-get install -y \
            texlive \
            texlive-xetex \
            texlive-latex-recommended \
            texlive-latex-extra \
            texlive-fonts-recommended \
            texlive-fonts-extra \
            texlive-lang-chinese \
            texlive-lang-cjk \
            texlive-science \
            texlive-pictures \
            texlive-luatex \
            lmodern \
            fonts-noto-cjk \
            fonts-wqy-microhei \
            fonts-wqy-zenhei \
            fonts-font-awesome
          
          # 验证安装
          echo "TeX Live 组件验证:"
          which xelatex && xelatex --version | head -1
          which pandoc && pandoc --version | head -1
          
          # 安装 Python 包
          pip3 install --upgrade pip
          pip3 install pyyaml beautifulsoup4
      
      - name: Create comprehensive LaTeX template
        run: |
          # 创建完整的 LaTeX 模板
          cat > /tmp/custom-template.tex << 'EOF'
          \documentclass[12pt,a4paper]{article}
          
          % 中文支持
          \usepackage{xeCJK}
          \setCJKmainfont{Noto Serif CJK SC}
          \setCJKsansfont{Noto Sans CJK SC}
          \setCJKmonofont{Noto Sans Mono CJK SC}
          
          % 代码块处理 - listings 包
          \usepackage{listings}
          \usepackage{xcolor}
          \usepackage{bera}
          
          % 页面布局
          \usepackage[top=2.5cm,bottom=2.5cm,left=2.5cm,right=2.5cm]{geometry}
          
          % 图片支持
          \usepackage{graphicx}
          \usepackage{float}
          \usepackage[font=small,labelfont=bf]{caption}
          \usepackage{subcaption}
          
          % 超链接
          \usepackage[hidelinks]{hyperref}
          
          % 页眉页脚
          \usepackage{fancyhdr}
          \pagestyle{fancy}
          \fancyhf{}
          \fancyhead[L]{\nouppercase{\leftmark}}
          \fancyhead[R]{\thepage}
          \renewcommand{\headrulewidth}{0.4pt}
          
          % 标题格式
          \usepackage{titlesec}
          \titleformat{\section}
            {\Large\bfseries\sffamily}
            {\thesection}
            {1em}
            {}
          \titleformat{\subsection}
            {\large\bfseries\sffamily}
            {\thesubsection}
            {1em}
            {}
          \titleformat{\subsubsection}
            {\normalsize\bfseries\sffamily}
            {\thesubsubsection}
            {1em}
            {}
          
          % 列表格式
          \usepackage{enumitem}
          \setlist[itemize]{leftmargin=*,topsep=5pt,parsep=0pt,itemsep=0pt}
          \setlist[enumerate]{leftmargin=*,topsep=5pt,parsep=0pt,itemsep=0pt}
          
          % 代码块样式 - 解决换行问题
          \lstset{
            basicstyle=\ttfamily\footnotesize,
            breaklines=true,                    % 自动换行
            breakatwhitespace=true,             % 在空格处换行
            breakindent=20pt,                   % 换行后的缩进
            breakautoindent=true,
            postbreak=\space\space,             % 换行后的字符
            showstringspaces=false,
            tabsize=2,
            frame=single,
            framesep=6pt,
            framerule=0.8pt,
            rulecolor=\color{gray},
            numbers=left,
            numberstyle=\tiny\color{gray},
            numbersep=10pt,
            stepnumber=1,
            backgroundcolor=\color{gray!10},
            keywordstyle=\color{blue}\bfseries,
            commentstyle=\color{green!60!black},
            stringstyle=\color{orange},
            identifierstyle=\color{black},
            extendedchars=true,
            literate=
              {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
              {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
              {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
              {À}{{\`A}}1 {È}{{\`E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
              {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
              {Ä}{{\"A}}1 {Ë}{{\'E}}1 {Ï}{{\'I}}1 {Ö}{{\'O}}1 {Ü}{{\'U}}1
              {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
              {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
              {ã}{{\~a}}1 {ẽ}{{\~e}}1 {ĩ}{{\~i}}1 {õ}{{\~o}}1 {ũ}{{\~u}}1
              {Ã}{{\~A}}1 {Ẽ}{{\~E}}1 {Ĩ}{{\~I}}1 {Õ}{{\~O}}1 {Ũ}{{\'U}}1
              {ç}{{\c c}}1 {Ç}{{\c C}}1
              {ø}{{\o}}1 {Ø}{{\O}}1
              {å}{{\r a}}1 {Å}{{\r A}}1
              {œ}{{\oe}}1 {Œ}{{\OE}}1
              {æ}{{\ae}}1 {Æ}{{\AE}}1
              {ß}{{\ss}}1
              {ñ}{{\~n}}1 {Ñ}{{\~N}}1
              {¿}{{?`}}1 {¡}{{!`}}1,
            captionpos=b,
            abovecaptionskip=10pt,
            belowcaptionskip=10pt
          }
          
          % 针对 C++ 的额外设置
          \lstdefinelanguage{C++}{
            language=C++,
            style=base,
            morekeywords={constexpr, auto, nullptr, std, uint32_t, uint16_t, int64_t, uint8_t, size_t},
            deletekeywords={register},
            sensitive=true
          }
          
          % 段落设置
          \usepackage{parskip}
          \setlength{\parindent}{0pt}
          \setlength{\parskip}{0.75em}
          
          % 颜色定义
          \definecolor{lightgray}{rgb}{0.95,0.95,0.95}
          \definecolor{darkgray}{rgb}{0.4,0.4,0.4}
          
          \begin{document}
          
          $if(title)$
          \title{$title$}
          \author{$author$}
          \date{$date$}
          \maketitle
          $endif$
          
          $if(toc)$
          \tableofcontents
          \newpage
          $endif$
          
          $body$
          
          \end{document}
          EOF
          
          echo "完整 LaTeX 模板已创建"
      
      - name: Create Python preprocessing script
        run: |
          # 创建独立的 Python 预处理脚本文件
          cat > /tmp/preprocess_markdown.py << 'EOF'
          #!/usr/bin/env python3
          import re
          import os
          import sys
          
          def preprocess_markdown(input_file):
              """预处理 Markdown 文件"""
              
              # 读取文件内容
              try:
                  with open(input_file, 'r', encoding='utf-8') as f:
                      content = f.read()
              except Exception as e:
                  print(f"读取文件错误: {e}", file=sys.stderr)
                  return None
              
              # 获取文件所在目录
              file_dir = os.path.dirname(input_file)
              if file_dir == '':
                  file_dir = '.'
              
              # 1. 修复图片路径
              def fix_image_path(match):
                  alt_text = match.group(1)
                  img_path = match.group(2)
                  
                  # 去除开头的 ./
                  if img_path.startswith('./'):
                      img_path = img_path[2:]
                  
                  # 检查文件是否存在
                  full_path = os.path.join(file_dir, img_path)
                  if os.path.exists(full_path):
                      # 使用相对路径
                      return f'![{alt_text}]({img_path})'
                  else:
                      # 尝试其他可能的位置
                      if img_path.startswith('picture/') or img_path.startswith('resource/'):
                          return f'![{alt_text}]({img_path})'
                      else:
                          # 如果图片在 picture 目录中
                          picture_path = os.path.join(file_dir, 'picture', os.path.basename(img_path))
                          if os.path.exists(picture_path):
                              return f'![{alt_text}](picture/{os.path.basename(img_path)})'
                  
                  return match.group(0)
              
              # 替换所有图片路径
              pattern = r'!\[(.*?)\]\((.*?)\)'
              content = re.sub(pattern, fix_image_path, content)
              
              # 2. 修复代码块 - 确保代码块有正确的语言标记和格式
              # 找到所有代码块
              code_blocks = re.findall(r'```(\w*)\n(.*?)```', content, re.DOTALL)
              for lang, code in code_blocks:
                  # 清理代码中的多余空格和换行
                  code = code.strip()
                  # 在每行末尾添加换行
                  lines = code.split('\n')
                  cleaned_lines = []
                  for line in lines:
                      line = line.rstrip()
                      cleaned_lines.append(line)
                  cleaned_code = '\n'.join(cleaned_lines)
                  # 替换原始代码块
                  old_block = f'```{lang}\n{code}```'
                  new_block = f'```{lang}\n{cleaned_code}\n```'
                  content = content.replace(old_block, new_block)
              
              # 3. 修复特殊字符
              content = content.replace('Δ', '△')
              content = content.replace('️', '')
              
              # 4. 修复标题格式
              content = re.sub(r'([^\n])\n#', r'\1\n\n#', content)
              content = re.sub(r'#(.*?)\n([^\n])', r'#\1\n\n\2', content)
              
              # 5. 修复列表格式
              content = re.sub(r'([^\n])\n\* ', r'\1\n\n* ', content)
              content = re.sub(r'\n\* (.*?)\n([^\n])', r'\n* \1\n\n\2', content)
              
              # 6. 修复表格格式
              content = re.sub(r'\|(.*?)\|\n([^\|])', r'|\1|\n\n\2', content)
              
              # 7. 修复代码中的换行（特别处理）
              # 在分号、大括号后添加换行，如果行太长
              lines = content.split('\n')
              in_code_block = False
              code_block_lang = ''
              processed_lines = []
              
              for line in lines:
                  if line.startswith('```'):
                      in_code_block = not in_code_block
                      if in_code_block:
                          code_block_lang = line[3:].strip()
                      else:
                          code_block_lang = ''
                      processed_lines.append(line)
                      continue
                  
                  if in_code_block and code_block_lang in ['cpp', 'c', 'c++', 'python']:
                      # 对于代码块中的长行，在适当位置添加换行
                      if len(line) > 80 and (';' in line or '{' in line or '}' in line):
                          # 在分号后添加换行
                          line = re.sub(r';\s*', ';\n    ', line)
                          # 在左大括号后添加换行
                          line = re.sub(r'\{\s*', '{\n    ', line)
                          # 在右大括号前添加换行
                          line = re.sub(r'\s*\}', '\n}', line)
                      processed_lines.append(line)
                  else:
                      processed_lines.append(line)
              
              content = '\n'.join(processed_lines)
              
              return content
          
          if __name__ == "__main__":
              if len(sys.argv) != 2:
                  print("使用方法: python3 preprocess_markdown.py <markdown文件>")
                  sys.exit(1)
              
              input_file = sys.argv[1]
              result = preprocess_markdown(input_file)
              
              if result is not None:
                  print(result)
              else:
                  sys.exit(1)
          EOF
          
          # 使脚本可执行
          chmod +x /tmp/preprocess_markdown.py
          
          echo "Python 预处理脚本已创建"
      
      - name: Prepare for conversion
        run: |
          echo "准备转换环境..."
          
          # 创建输出目录
          mkdir -p pdf_output
          
          # 显示当前目录结构
          echo "当前目录结构:"
          find . -maxdepth 3 -type d | sort
          
          # 检查工具版本
          echo "工具版本:"
          pandoc --version | head -3
          xelatex --version | head -2
          python3 --version
      
      - name: Comprehensive Markdown to PDF conversion
        run: |
          echo "开始综合 Markdown 到 PDF 转换..."
          
          # 获取当前工作目录
          WORKING_DIR=$(pwd)
          echo "工作目录: $WORKING_DIR"
          
          # 查找所有 Markdown 文件
          echo "查找 Markdown 文件..."
          
          # 创建文件列表
          find . -name "*.md" \
            ! -path "./.*" \
            ! -path "*/node_modules/*" \
            ! -path "*/pdf_output/*" \
            -type f > /tmp/markdown_files.txt
          
          # 统计文件数量
          FILE_COUNT=$(wc -l < /tmp/markdown_files.txt)
          echo "找到 $FILE_COUNT 个 Markdown 文件"
          
          # 处理每个文件
          while IFS= read -r md_file; do
            echo ""
            echo "处理文件: $md_file"
            
            # 获取文件信息
            dir_name=$(dirname "$md_file")
            base_name=$(basename "$md_file" .md)
            
            # 创建输出目录
            mkdir -p "pdf_output/$dir_name"
            
            echo "  复制资源文件..."
            
            # 复制图片目录
            if [ -d "$dir_name/picture" ]; then
              echo "    复制 picture 目录..."
              mkdir -p "pdf_output/$dir_name/picture"
              # 使用 cp 复制文件，保留目录结构
              find "$dir_name/picture" -type f \( -name "*.png" -o -name "*.jpg" -o -name "*.jpeg" -o -name "*.gif" -o -name "*.bmp" \) \
                -exec cp --parents {} "pdf_output/" \; 2>/dev/null || true
            fi
            
            # 复制资源目录
            if [ -d "$dir_name/resource" ]; then
              echo "    复制 resource 目录..."
              mkdir -p "pdf_output/$dir_name/resource"
              find "$dir_name/resource" -type f \( -name "*.zip" -o -name "*.pdf" -o -name "*.txt" -o -name "*.ino" -o -name "*.cpp" -o -name "*.h" \) \
                -exec cp --parents {} "pdf_output/" \; 2>/dev/null || true
            fi
            
            # 检查文件是否存在
            if [ ! -f "$md_file" ]; then
              echo "  ✗ 错误: 文件不存在: $md_file"
              continue
            fi
            
            # 预处理 Markdown 文件
            echo "  预处理 Markdown 文件..."
            
            # 创建临时文件
            TEMP_FILE="$(mktemp)"
            
            # 使用独立的 Python 脚本处理
            if python3 /tmp/preprocess_markdown.py "$md_file" > "$TEMP_FILE" 2>/dev/null; then
              echo "    预处理成功"
            else
              echo "    预处理失败，使用原始文件"
              cp "$md_file" "$TEMP_FILE"
            fi
            
            # 检查预处理是否成功
            if [ ! -s "$TEMP_FILE" ]; then
              echo "    警告: 预处理后文件为空，使用原始文件"
              cp "$md_file" "$TEMP_FILE"
            fi
            
            # 构建资源路径
            RESOURCE_PATHS=(
              "$WORKING_DIR/$dir_name"
              "$WORKING_DIR"
              "."
              "$dir_name"
              "$WORKING_DIR/$dir_name/picture"
              "$WORKING_DIR/$dir_name/resource"
            )
            
            # 构建资源路径字符串
            RESOURCE_PATH=$(IFS=:; echo "${RESOURCE_PATHS[*]}")
            
            # 使用 pandoc 转换 PDF
            echo "  使用 Pandoc 转换..."
            
            # 设置输出文件路径
            OUTPUT_PDF="pdf_output/$dir_name/$base_name.pdf"
            
            set +e
            PANDOC_OUTPUT=$(pandoc "$TEMP_FILE" \
              --resource-path="$RESOURCE_PATH" \
              -o "$OUTPUT_PDF" \
              --pdf-engine=xelatex \
              --template=/tmp/custom-template.tex \
              -V mainfont="Noto Serif CJK SC" \
              -V sansfont="Noto Sans CJK SC" \
              -V monofont="Noto Sans Mono CJK SC" \
              -V geometry="margin=2.5cm" \
              -V colorlinks=true \
              -V linkcolor=blue \
              -V urlcolor=blue \
              --listings \
              --highlight-style=pygments \
              -V lang=zh-CN \
              -V documentclass=article \
              --toc \
              --toc-depth=3 \
              --wrap=none \
              -M date="$(date '+%Y-%m-%d')" \
              --metadata title="$base_name" \
              2>&1)
            
            PANDOC_EXIT=$?
            set -e
            
            # 检查结果
            if [ $PANDOC_EXIT -eq 0 ] && [ -f "$OUTPUT_PDF" ]; then
              # 获取文件信息
              FILE_SIZE=$(du -h "$OUTPUT_PDF" | cut -f1)
              
              echo "  ✅ 成功: $base_name.pdf ($FILE_SIZE)"
              
              # 验证内容
              echo "    内容验证:"
              
              # 检查代码块
              if pdftotext "$OUTPUT_PDF" - 2>/dev/null | head -50 | grep -q "#include"; then
                echo "      ✓ 检测到代码块"
              else
                echo "      ⚠ 未检测到代码块"
              fi
              
              # 检查图片引用
              if pdftotext "$OUTPUT_PDF" - 2>/dev/null | grep -q "图像\|图片\|image"; then
                echo "      ✓ 检测到图片引用"
              else
                echo "      ⚠ 未检测到图片引用"
              fi
              
              # 检查中文内容
              if pdftotext "$OUTPUT_PDF" - 2>/dev/null | head -20 | grep -q "课程\|实验\|硬件"; then
                echo "      ✓ 检测到中文内容"
              fi
              
            else
              echo "  ❌ 失败: $md_file"
              
              # 显示错误日志
              echo "    Pandoc 退出代码: $PANDOC_EXIT"
              echo "    错误信息:"
              echo "$PANDOC_OUTPUT" | head -20 | sed 's/^/      /'
              
              # 尝试简单测试
              echo "    尝试简单测试..."
              echo "# Test" > /tmp/test.md
              echo "Test content" >> /tmp/test.md
              echo '```cpp' >> /tmp/test.md
              echo '#include <iostream>' >> /tmp/test.md
              echo 'int main() { return 0; }' >> /tmp/test.md
              echo '```' >> /tmp/test.md
              
              if pandoc /tmp/test.md -o /tmp/test.pdf --pdf-engine=xelatex 2>/dev/null; then
                echo "      简单测试成功"
              else
                echo "      简单测试失败"
              fi
            fi
            
            # 清理临时文件
            rm -f "$TEMP_FILE" 2>/dev/null || true
            
          done < /tmp/markdown_files.txt
          
          # 显示转换统计
          echo ""
          echo "转换统计:"
          TOTAL_PDFS=$(find pdf_output -name "*.pdf" -type f | wc -l)
          echo "总共生成 $TOTAL_PDFS 个 PDF 文件"
      
      - name: Verify PDF output quality
        run: |
          echo "验证 PDF 输出质量..."
          
          # 检查每个 PDF 文件
          find pdf_output -name "*.pdf" -type f | head -3 | while read pdf_file; do
            echo ""
            echo "检查文件: $pdf_file"
            
            # 检查 PDF 基本信息
            if command -v pdfinfo > /dev/null 2>&1; then
              if pdfinfo "$pdf_file" > /dev/null 2>&1; then
                PAGE_COUNT=$(pdfinfo "$pdf_file" 2>/dev/null | grep "Pages:" | awk '{print $2}' || echo "N/A")
                FILE_SIZE=$(du -h "$pdf_file" | cut -f1)
                echo "  ✅ 有效 PDF ($FILE_SIZE, $PAGE_COUNT 页)"
                
                # 提取文本检查
                echo "    文本预览（前5行）:"
                pdftotext "$pdf_file" - 2>/dev/null | head -5 | sed 's/^/      /'
                
              else
                echo "  ❌ 无效 PDF 文件"
              fi
            else
              echo "  ℹ 无法检查 PDF 信息 (pdfinfo 不可用)"
            fi
          done
      
      - name: Create documentation and summary
        run: |
          echo "创建文档和摘要..."
          
          # 创建 README 文件
          cat > pdf_output/README.md << 'EOF'
          # PDF 文档集
          
          ## 生成信息
          
          - **生成时间**: $(date '+%Y-%m-%d %H:%M:%S')
          - **GitHub SHA**: ${{ github.sha }}
          - **触发事件**: ${{ github.event_name }}
          - **工作流**: ${{ github.workflow }}
          
          ## 转换设置
          
          - **模板**: 自定义 LaTeX 模板
          - **字体**: Noto Serif CJK SC (中文)
          - **代码块**: listings 包 (自动换行)
          - **图片**: 支持 PNG, JPG, GIF, BMP
          
          ## 文件列表
          
          EOF
          
          # 统计 PDF 文件
          PDF_COUNT=$(find pdf_output -name "*.pdf" -type f | wc -l)
          echo "**总计: $PDF_COUNT 个 PDF 文件**" >> pdf_output/README.md
          echo "" >> pdf_output/README.md
          
          # 按目录组织文件列表
          current_dir=""
          find pdf_output -name "*.pdf" -type f | sort | while read pdf_file; do
            rel_path=${pdf_file#pdf_output/}
            dir_name=$(dirname "$rel_path")
            file_name=$(basename "$pdf_file")
            file_size=$(du -h "$pdf_file" | cut -f1)
            
            if [ "$current_dir" != "$dir_name" ]; then
              current_dir="$dir_name"
              if [ "$dir_name" != "." ]; then
                echo "### $dir_name/" >> pdf_output/README.md
                echo "" >> pdf_output/README.md
              fi
            fi
            
            echo "- [$file_name]($rel_path) ($file_size)" >> pdf_output/README.md
          done
      
      - name: Package PDFs for release
        if: startsWith(github.ref, 'refs/tags/')
        run: |
          echo "打包 PDF 文件用于发布..."
          
          TAG_NAME="${GITHUB_REF#refs/tags/}"
          ZIP_NAME="pdf-documents-${TAG_NAME}.zip"
          
          # 创建压缩包
          cd pdf_output
          zip -r "../$ZIP_NAME" .
          cd ..
          
          echo "压缩包已创建: $ZIP_NAME"
          ls -lh "$ZIP_NAME"
      
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: pdf-documents
          path: |
            pdf_output/
            pdf-documents-*.zip
          retention-days: 7
      
      - name: Create GitHub Release
        if: startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.ref_name }}
          name: "PDF Documents - ${{ github.ref_name }}"
          body_path: pdf_output/README.md
          files: |
            pdf-documents-${{ github.ref_name }}.zip
          draft: false
          prerelease: false
          generate_release_notes: true
      
      - name: Final verification
        run: |
          echo "最终验证..."
          
          echo "✅ PDF 转换工作流完成"
          echo ""
          echo "生成的文件:"
          find pdf_output -name "*.pdf" -type f | wc -l | xargs echo "- PDF 文件:"
          find pdf_output -name "*.png" -o -name "*.jpg" -o -name "*.jpeg" | wc -l | xargs echo "- 图片文件:"
          
          echo ""
          echo "输出目录结构:"
          find pdf_output -maxdepth 3 -type d | sort | sed 's/^/  /'